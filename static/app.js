(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * @fileoverview
 * @enhanceable
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

goog.exportSymbol('proto.LinkAnnotation', null, global);
goog.exportSymbol('proto.List', null, global);
goog.exportSymbol('proto.ListItem', null, global);
goog.exportSymbol('proto.StreetEasyAnnotation', null, global);
goog.exportSymbol('proto.TextAnnotation', null, global);
goog.exportSymbol('proto.User', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.User = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.User, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.User.displayName = 'proto.User';
}

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto suitable for use in Soy templates.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
   * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
   *     for transitional soy proto support: http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.User.prototype.toObject = function (opt_includeInstance) {
    return proto.User.toObject(opt_includeInstance, this);
  };

  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Whether to include the JSPB
   *     instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.User} msg The msg instance to transform.
   * @return {!Object}
   */
  proto.User.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      id: jspb.Message.getFieldWithDefault(msg, 1, 0),
      name: jspb.Message.getFieldWithDefault(msg, 2, "")
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }
    return obj;
  };
}

/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.User}
 */
proto.User.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.User();
  return proto.User.deserializeBinaryFromReader(msg, reader);
};

/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.User} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.User}
 */
proto.User.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
      case 1:
        var value = /** @type {number} */reader.readInt64();
        msg.setId(value);
        break;
      case 2:
        var value = /** @type {string} */reader.readString();
        msg.setName(value);
        break;
      default:
        reader.skipField();
        break;
    }
  }
  return msg;
};

/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.User} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.User.serializeBinaryToWriter = function (message, writer) {
  message.serializeBinaryToWriter(writer);
};

/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.User.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};

/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.User.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getId();
  if (f !== 0) {
    writer.writeInt64(1, f);
  }
  f = this.getName();
  if (f.length > 0) {
    writer.writeString(2, f);
  }
};

/**
 * optional int64 id = 1;
 * @return {number}
 */
proto.User.prototype.getId = function () {
  return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
  );
};

/** @param {number} value */
proto.User.prototype.setId = function (value) {
  jspb.Message.setField(this, 1, value);
};

/**
 * optional string name = 2;
 * @return {string}
 */
proto.User.prototype.getName = function () {
  return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 2, "")
  );
};

/** @param {string} value */
proto.User.prototype.setName = function (value) {
  jspb.Message.setField(this, 2, value);
};

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.List = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.List.repeatedFields_, null);
};
goog.inherits(proto.List, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.List.displayName = 'proto.List';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.List.repeatedFields_ = [2];

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto suitable for use in Soy templates.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
   * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
   *     for transitional soy proto support: http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.List.prototype.toObject = function (opt_includeInstance) {
    return proto.List.toObject(opt_includeInstance, this);
  };

  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Whether to include the JSPB
   *     instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.List} msg The msg instance to transform.
   * @return {!Object}
   */
  proto.List.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      name: jspb.Message.getFieldWithDefault(msg, 1, ""),
      itemsList: jspb.Message.toObjectList(msg.getItemsList(), proto.ListItem.toObject, includeInstance)
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }
    return obj;
  };
}

/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.List}
 */
proto.List.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.List();
  return proto.List.deserializeBinaryFromReader(msg, reader);
};

/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.List} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.List}
 */
proto.List.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
      case 1:
        var value = /** @type {string} */reader.readString();
        msg.setName(value);
        break;
      case 2:
        var value = new proto.ListItem();
        reader.readMessage(value, proto.ListItem.deserializeBinaryFromReader);
        msg.addItems(value);
        break;
      default:
        reader.skipField();
        break;
    }
  }
  return msg;
};

/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.List} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.List.serializeBinaryToWriter = function (message, writer) {
  message.serializeBinaryToWriter(writer);
};

/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.List.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};

/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.List.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getName();
  if (f.length > 0) {
    writer.writeString(1, f);
  }
  f = this.getItemsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(2, f, proto.ListItem.serializeBinaryToWriter);
  }
};

/**
 * optional string name = 1;
 * @return {string}
 */
proto.List.prototype.getName = function () {
  return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 1, "")
  );
};

/** @param {string} value */
proto.List.prototype.setName = function (value) {
  jspb.Message.setField(this, 1, value);
};

/**
 * repeated ListItem items = 2;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.ListItem>}
 */
proto.List.prototype.getItemsList = function () {
  return (/** @type{!Array.<!proto.ListItem>} */jspb.Message.getRepeatedWrapperField(this, proto.ListItem, 2)
  );
};

/** @param {!Array.<!proto.ListItem>} value */
proto.List.prototype.setItemsList = function (value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};

/**
 * @param {!proto.ListItem=} opt_value
 * @param {number=} opt_index
 * @return {!proto.ListItem}
 */
proto.List.prototype.addItems = function (opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.ListItem, opt_index);
};

proto.List.prototype.clearItemsList = function () {
  this.setItemsList([]);
};

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ListItem = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.ListItem.repeatedFields_, null);
};
goog.inherits(proto.ListItem, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ListItem.displayName = 'proto.ListItem';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.ListItem.repeatedFields_ = [4, 5, 6];

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto suitable for use in Soy templates.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
   * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
   *     for transitional soy proto support: http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.ListItem.prototype.toObject = function (opt_includeInstance) {
    return proto.ListItem.toObject(opt_includeInstance, this);
  };

  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Whether to include the JSPB
   *     instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.ListItem} msg The msg instance to transform.
   * @return {!Object}
   */
  proto.ListItem.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      id: jspb.Message.getFieldWithDefault(msg, 1, 0),
      name: jspb.Message.getFieldWithDefault(msg, 2, ""),
      description: jspb.Message.getFieldWithDefault(msg, 3, ""),
      linkAnnotationsList: jspb.Message.toObjectList(msg.getLinkAnnotationsList(), proto.LinkAnnotation.toObject, includeInstance),
      textAnnotationsList: jspb.Message.toObjectList(msg.getTextAnnotationsList(), proto.TextAnnotation.toObject, includeInstance),
      streeteasyAnnotationsList: jspb.Message.toObjectList(msg.getStreeteasyAnnotationsList(), proto.StreetEasyAnnotation.toObject, includeInstance)
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }
    return obj;
  };
}

/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ListItem}
 */
proto.ListItem.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ListItem();
  return proto.ListItem.deserializeBinaryFromReader(msg, reader);
};

/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ListItem} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ListItem}
 */
proto.ListItem.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
      case 1:
        var value = /** @type {number} */reader.readInt64();
        msg.setId(value);
        break;
      case 2:
        var value = /** @type {string} */reader.readString();
        msg.setName(value);
        break;
      case 3:
        var value = /** @type {string} */reader.readString();
        msg.setDescription(value);
        break;
      case 4:
        var value = new proto.LinkAnnotation();
        reader.readMessage(value, proto.LinkAnnotation.deserializeBinaryFromReader);
        msg.addLinkAnnotations(value);
        break;
      case 5:
        var value = new proto.TextAnnotation();
        reader.readMessage(value, proto.TextAnnotation.deserializeBinaryFromReader);
        msg.addTextAnnotations(value);
        break;
      case 6:
        var value = new proto.StreetEasyAnnotation();
        reader.readMessage(value, proto.StreetEasyAnnotation.deserializeBinaryFromReader);
        msg.addStreeteasyAnnotations(value);
        break;
      default:
        reader.skipField();
        break;
    }
  }
  return msg;
};

/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.ListItem} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.ListItem.serializeBinaryToWriter = function (message, writer) {
  message.serializeBinaryToWriter(writer);
};

/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ListItem.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};

/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.ListItem.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getId();
  if (f !== 0) {
    writer.writeInt64(1, f);
  }
  f = this.getName();
  if (f.length > 0) {
    writer.writeString(2, f);
  }
  f = this.getDescription();
  if (f.length > 0) {
    writer.writeString(3, f);
  }
  f = this.getLinkAnnotationsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(4, f, proto.LinkAnnotation.serializeBinaryToWriter);
  }
  f = this.getTextAnnotationsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(5, f, proto.TextAnnotation.serializeBinaryToWriter);
  }
  f = this.getStreeteasyAnnotationsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(6, f, proto.StreetEasyAnnotation.serializeBinaryToWriter);
  }
};

/**
 * optional int64 id = 1;
 * @return {number}
 */
proto.ListItem.prototype.getId = function () {
  return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
  );
};

/** @param {number} value */
proto.ListItem.prototype.setId = function (value) {
  jspb.Message.setField(this, 1, value);
};

/**
 * optional string name = 2;
 * @return {string}
 */
proto.ListItem.prototype.getName = function () {
  return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 2, "")
  );
};

/** @param {string} value */
proto.ListItem.prototype.setName = function (value) {
  jspb.Message.setField(this, 2, value);
};

/**
 * optional string description = 3;
 * @return {string}
 */
proto.ListItem.prototype.getDescription = function () {
  return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 3, "")
  );
};

/** @param {string} value */
proto.ListItem.prototype.setDescription = function (value) {
  jspb.Message.setField(this, 3, value);
};

/**
 * repeated LinkAnnotation link_annotations = 4;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.LinkAnnotation>}
 */
proto.ListItem.prototype.getLinkAnnotationsList = function () {
  return (/** @type{!Array.<!proto.LinkAnnotation>} */jspb.Message.getRepeatedWrapperField(this, proto.LinkAnnotation, 4)
  );
};

/** @param {!Array.<!proto.LinkAnnotation>} value */
proto.ListItem.prototype.setLinkAnnotationsList = function (value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};

/**
 * @param {!proto.LinkAnnotation=} opt_value
 * @param {number=} opt_index
 * @return {!proto.LinkAnnotation}
 */
proto.ListItem.prototype.addLinkAnnotations = function (opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.LinkAnnotation, opt_index);
};

proto.ListItem.prototype.clearLinkAnnotationsList = function () {
  this.setLinkAnnotationsList([]);
};

/**
 * repeated TextAnnotation text_annotations = 5;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.TextAnnotation>}
 */
proto.ListItem.prototype.getTextAnnotationsList = function () {
  return (/** @type{!Array.<!proto.TextAnnotation>} */jspb.Message.getRepeatedWrapperField(this, proto.TextAnnotation, 5)
  );
};

/** @param {!Array.<!proto.TextAnnotation>} value */
proto.ListItem.prototype.setTextAnnotationsList = function (value) {
  jspb.Message.setRepeatedWrapperField(this, 5, value);
};

/**
 * @param {!proto.TextAnnotation=} opt_value
 * @param {number=} opt_index
 * @return {!proto.TextAnnotation}
 */
proto.ListItem.prototype.addTextAnnotations = function (opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, proto.TextAnnotation, opt_index);
};

proto.ListItem.prototype.clearTextAnnotationsList = function () {
  this.setTextAnnotationsList([]);
};

/**
 * repeated StreetEasyAnnotation streeteasy_annotations = 6;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.StreetEasyAnnotation>}
 */
proto.ListItem.prototype.getStreeteasyAnnotationsList = function () {
  return (/** @type{!Array.<!proto.StreetEasyAnnotation>} */jspb.Message.getRepeatedWrapperField(this, proto.StreetEasyAnnotation, 6)
  );
};

/** @param {!Array.<!proto.StreetEasyAnnotation>} value */
proto.ListItem.prototype.setStreeteasyAnnotationsList = function (value) {
  jspb.Message.setRepeatedWrapperField(this, 6, value);
};

/**
 * @param {!proto.StreetEasyAnnotation=} opt_value
 * @param {number=} opt_index
 * @return {!proto.StreetEasyAnnotation}
 */
proto.ListItem.prototype.addStreeteasyAnnotations = function (opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 6, opt_value, proto.StreetEasyAnnotation, opt_index);
};

proto.ListItem.prototype.clearStreeteasyAnnotationsList = function () {
  this.setStreeteasyAnnotationsList([]);
};

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.LinkAnnotation = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.LinkAnnotation, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.LinkAnnotation.displayName = 'proto.LinkAnnotation';
}

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto suitable for use in Soy templates.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
   * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
   *     for transitional soy proto support: http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.LinkAnnotation.prototype.toObject = function (opt_includeInstance) {
    return proto.LinkAnnotation.toObject(opt_includeInstance, this);
  };

  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Whether to include the JSPB
   *     instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.LinkAnnotation} msg The msg instance to transform.
   * @return {!Object}
   */
  proto.LinkAnnotation.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      id: jspb.Message.getFieldWithDefault(msg, 1, 0),
      url: jspb.Message.getFieldWithDefault(msg, 2, "")
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }
    return obj;
  };
}

/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.LinkAnnotation}
 */
proto.LinkAnnotation.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.LinkAnnotation();
  return proto.LinkAnnotation.deserializeBinaryFromReader(msg, reader);
};

/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.LinkAnnotation} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.LinkAnnotation}
 */
proto.LinkAnnotation.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
      case 1:
        var value = /** @type {number} */reader.readInt64();
        msg.setId(value);
        break;
      case 2:
        var value = /** @type {string} */reader.readString();
        msg.setUrl(value);
        break;
      default:
        reader.skipField();
        break;
    }
  }
  return msg;
};

/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.LinkAnnotation} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.LinkAnnotation.serializeBinaryToWriter = function (message, writer) {
  message.serializeBinaryToWriter(writer);
};

/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.LinkAnnotation.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};

/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.LinkAnnotation.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getId();
  if (f !== 0) {
    writer.writeInt64(1, f);
  }
  f = this.getUrl();
  if (f.length > 0) {
    writer.writeString(2, f);
  }
};

/**
 * optional int64 id = 1;
 * @return {number}
 */
proto.LinkAnnotation.prototype.getId = function () {
  return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
  );
};

/** @param {number} value */
proto.LinkAnnotation.prototype.setId = function (value) {
  jspb.Message.setField(this, 1, value);
};

/**
 * optional string url = 2;
 * @return {string}
 */
proto.LinkAnnotation.prototype.getUrl = function () {
  return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 2, "")
  );
};

/** @param {string} value */
proto.LinkAnnotation.prototype.setUrl = function (value) {
  jspb.Message.setField(this, 2, value);
};

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TextAnnotation = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.TextAnnotation, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.TextAnnotation.displayName = 'proto.TextAnnotation';
}

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto suitable for use in Soy templates.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
   * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
   *     for transitional soy proto support: http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.TextAnnotation.prototype.toObject = function (opt_includeInstance) {
    return proto.TextAnnotation.toObject(opt_includeInstance, this);
  };

  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Whether to include the JSPB
   *     instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.TextAnnotation} msg The msg instance to transform.
   * @return {!Object}
   */
  proto.TextAnnotation.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      id: jspb.Message.getFieldWithDefault(msg, 1, 0),
      text: jspb.Message.getFieldWithDefault(msg, 2, "")
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }
    return obj;
  };
}

/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TextAnnotation}
 */
proto.TextAnnotation.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TextAnnotation();
  return proto.TextAnnotation.deserializeBinaryFromReader(msg, reader);
};

/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TextAnnotation} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TextAnnotation}
 */
proto.TextAnnotation.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
      case 1:
        var value = /** @type {number} */reader.readInt64();
        msg.setId(value);
        break;
      case 2:
        var value = /** @type {string} */reader.readString();
        msg.setText(value);
        break;
      default:
        reader.skipField();
        break;
    }
  }
  return msg;
};

/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.TextAnnotation} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.TextAnnotation.serializeBinaryToWriter = function (message, writer) {
  message.serializeBinaryToWriter(writer);
};

/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TextAnnotation.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};

/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.TextAnnotation.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getId();
  if (f !== 0) {
    writer.writeInt64(1, f);
  }
  f = this.getText();
  if (f.length > 0) {
    writer.writeString(2, f);
  }
};

/**
 * optional int64 id = 1;
 * @return {number}
 */
proto.TextAnnotation.prototype.getId = function () {
  return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
  );
};

/** @param {number} value */
proto.TextAnnotation.prototype.setId = function (value) {
  jspb.Message.setField(this, 1, value);
};

/**
 * optional string text = 2;
 * @return {string}
 */
proto.TextAnnotation.prototype.getText = function () {
  return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 2, "")
  );
};

/** @param {string} value */
proto.TextAnnotation.prototype.setText = function (value) {
  jspb.Message.setField(this, 2, value);
};

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.StreetEasyAnnotation = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.StreetEasyAnnotation.repeatedFields_, null);
};
goog.inherits(proto.StreetEasyAnnotation, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.StreetEasyAnnotation.displayName = 'proto.StreetEasyAnnotation';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.StreetEasyAnnotation.repeatedFields_ = [4];

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto suitable for use in Soy templates.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
   * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
   *     for transitional soy proto support: http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.StreetEasyAnnotation.prototype.toObject = function (opt_includeInstance) {
    return proto.StreetEasyAnnotation.toObject(opt_includeInstance, this);
  };

  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Whether to include the JSPB
   *     instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.StreetEasyAnnotation} msg The msg instance to transform.
   * @return {!Object}
   */
  proto.StreetEasyAnnotation.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      hash: jspb.Message.getFieldWithDefault(msg, 1, 0),
      name: jspb.Message.getFieldWithDefault(msg, 2, ""),
      priceUsd: jspb.Message.getFieldWithDefault(msg, 3, 0),
      openHousesList: jspb.Message.getField(msg, 4)
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }
    return obj;
  };
}

/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.StreetEasyAnnotation}
 */
proto.StreetEasyAnnotation.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.StreetEasyAnnotation();
  return proto.StreetEasyAnnotation.deserializeBinaryFromReader(msg, reader);
};

/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.StreetEasyAnnotation} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.StreetEasyAnnotation}
 */
proto.StreetEasyAnnotation.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
      case 1:
        var value = /** @type {number} */reader.readUint64();
        msg.setHash(value);
        break;
      case 2:
        var value = /** @type {string} */reader.readString();
        msg.setName(value);
        break;
      case 3:
        var value = /** @type {number} */reader.readInt32();
        msg.setPriceUsd(value);
        break;
      case 4:
        var value = /** @type {string} */reader.readString();
        msg.addOpenHouses(value);
        break;
      default:
        reader.skipField();
        break;
    }
  }
  return msg;
};

/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.StreetEasyAnnotation} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.StreetEasyAnnotation.serializeBinaryToWriter = function (message, writer) {
  message.serializeBinaryToWriter(writer);
};

/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.StreetEasyAnnotation.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};

/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.StreetEasyAnnotation.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getHash();
  if (f !== 0) {
    writer.writeUint64(1, f);
  }
  f = this.getName();
  if (f.length > 0) {
    writer.writeString(2, f);
  }
  f = this.getPriceUsd();
  if (f !== 0) {
    writer.writeInt32(3, f);
  }
  f = this.getOpenHousesList();
  if (f.length > 0) {
    writer.writeRepeatedString(4, f);
  }
};

/**
 * optional uint64 hash = 1;
 * @return {number}
 */
proto.StreetEasyAnnotation.prototype.getHash = function () {
  return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
  );
};

/** @param {number} value */
proto.StreetEasyAnnotation.prototype.setHash = function (value) {
  jspb.Message.setField(this, 1, value);
};

/**
 * optional string name = 2;
 * @return {string}
 */
proto.StreetEasyAnnotation.prototype.getName = function () {
  return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 2, "")
  );
};

/** @param {string} value */
proto.StreetEasyAnnotation.prototype.setName = function (value) {
  jspb.Message.setField(this, 2, value);
};

/**
 * optional int32 price_usd = 3;
 * @return {number}
 */
proto.StreetEasyAnnotation.prototype.getPriceUsd = function () {
  return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 3, 0)
  );
};

/** @param {number} value */
proto.StreetEasyAnnotation.prototype.setPriceUsd = function (value) {
  jspb.Message.setField(this, 3, value);
};

/**
 * repeated string open_houses = 4;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<string>}
 */
proto.StreetEasyAnnotation.prototype.getOpenHousesList = function () {
  return (/** @type {!Array.<string>} */jspb.Message.getField(this, 4)
  );
};

/** @param {!Array.<string>} value */
proto.StreetEasyAnnotation.prototype.setOpenHousesList = function (value) {
  jspb.Message.setField(this, 4, value || []);
};

/**
 * @param {!string} value
 * @param {number=} opt_index
 */
proto.StreetEasyAnnotation.prototype.addOpenHouses = function (value, opt_index) {
  jspb.Message.addToRepeatedField(this, 4, value, opt_index);
};

proto.StreetEasyAnnotation.prototype.clearOpenHousesList = function () {
  this.setOpenHousesList([]);
};

goog.object.extend(exports, proto);

},{"google-protobuf":"google-protobuf"}],2:[function(require,module,exports){
var React = require('react');
var ReactDOM = require('react-dom');
var ReactRouter = require('react-router');
var $ = require('jquery');

var model = require('./model.js');
var api = require('./api_pb.js');

var sockets_api = require('./sockets_api_pb.js');

var UserPicker = React.createClass({
  displayName: 'UserPicker',

  getInitialState: function () {
    return { users: [] };
  },
  componentDidMount: function () {
    $.ajax({
      url: '/users',
      dataType: 'json',
      cache: false,
      success: function (data) {
        console.log(data);
        this.setState({ users: data.map(model.user_from_json) });
      }.bind(this),
      error: function (xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  render: function () {
    var userNodes = this.state.users.map(function (user) {
      return React.createElement(
        'li',
        { className: 'user', key: user.getId() },
        React.createElement(
          ReactRouter.Link,
          { to: `/lists/${ user.getId() }` },
          user.getName()
        )
      );
    });

    return React.createElement(
      'ul',
      { className: 'userPicker' },
      userNodes
    );
  }
});

var App = React.createClass({
  displayName: 'App',

  render: function () {
    return React.createElement(
      'div',
      null,
      React.cloneElement(this.props.children, {
        userId: this.props.params.userId
      })
    );
  }
});

var ListItem = React.createClass({
  displayName: 'ListItem',

  getInitialState: function () {
    return {
      addingLinkAnnotation: false,
      pendingLinkAnnotation: '',
      addingTextAnnotation: false,
      pendingTextAnnotation: ''
    };
  },
  delete: function () {
    this.props.deleteFn(this.props.data.id);
  },
  postAnnotation: function (annotationObj) {
    var url = `/lists/${ this.props.userId }/list/${ this.props.listId }/items/${ this.props.data.id }/annotations`;

    $.ajax({
      url: url,
      dataType: 'json',
      type: 'POST',
      data: JSON.stringify(annotationObj),
      success: function (data) {
        console.log("posted new annotation. got respnse: " + JSON.stringify(data));
        this.props.itemUpdatedFn(data);
      }.bind(this),
      error: function (xhr, status, err) {
        console.error(url, status, err.toString());
      }.bind(this)
    });
  },
  toggleTextAnnotationAdder: function () {
    this.setState({ addingTextAnnotation: !this.state.addingTextAnnotation });
  },
  pendingTextAnnotationChanged: function (e) {
    this.setState({ pendingTextAnnotation: e.target.value });
  },
  addTextAnnotation: function () {
    // TODO: The "TEXT" string should live on the server
    this.postAnnotation({ kind: "TEXT", body: this.state.pendingTextAnnotation });
    this.setState({ addingLinkAnnotation: false, pendingLinkAnnotation: '' });
  },
  toggleLinkAnnotationAdder: function () {
    this.setState({ addingLinkAnnotation: !this.state.addingLinkAnnotation });
  },
  pendingLinkAnnotationChanged: function (e) {
    this.setState({ pendingLinkAnnotation: e.target.value });
  },
  addLinkAnnotation: function () {
    // TODO: The "link" string should live on the server
    this.postAnnotation({ kind: "LINK", body: this.state.pendingLinkAnnotation });
    this.setState({ addingLinkAnnotation: false, pendingLinkAnnotation: '' });
  },
  render: function () {
    var linkNodes = this.props.data.link_annotations.map(function (link) {
      return React.createElement(
        'div',
        { className: 'annotation link', key: link.url },
        React.createElement(
          'a',
          { href: link.url, target: '_' },
          link.url
        )
      );
    });

    var streetEasyNodes = this.props.data.streeteasy_annotations.map(function (listing) {
      var openHouseNodes;

      if (listing.open_houses.length > 0) {
        var openHouseItems = listing.open_houses.map(function (open_house) {
          return React.createElement(
            'li',
            { key: open_house },
            open_house
          );
        });
        var openHouseNodes = React.createElement(
          'div',
          null,
          'Open Houses',
          React.createElement(
            'ul',
            null,
            openHouseItems
          )
        );
      }

      return React.createElement(
        'div',
        { className: 'annotation streeteasy', key: listing.hash },
        React.createElement(
          'div',
          { className: 'kind' },
          'StreetEasy'
        ),
        React.createElement(
          'div',
          { className: 'title' },
          listing.name
        ),
        'Price: $',
        listing.price_usd,
        openHouseNodes
      );
    });

    var textNodes = this.props.data.text_annotations.map(function (text) {
      return React.createElement(
        'div',
        { className: 'annotation text', key: text.id },
        text.text
      );
    });

    var addLinkNodes;
    if (this.state.addingLinkAnnotation) {
      addLinkNodes = React.createElement(
        'div',
        null,
        React.createElement('input', { type: 'text', placeholder: 'Url...', value: this.state.pendingLinkAnnotation, onChange: this.pendingLinkAnnotationChanged }),
        React.createElement(
          'button',
          { onClick: this.addLinkAnnotation },
          '+'
        )
      );
    }

    var addTextNodes;
    if (this.state.addingTextAnnotation) {
      addTextNodes = React.createElement(
        'div',
        null,
        React.createElement('input', { type: 'text', placeholder: 'Text...', value: this.state.pendingTextAnnotation, onChange: this.pendingTextAnnotationChanged }),
        React.createElement(
          'button',
          { onClick: this.addTextAnnotation },
          '+'
        )
      );
    }

    return React.createElement(
      'li',
      { className: 'listItem' },
      React.createElement(
        'div',
        { className: 'header' },
        React.createElement(
          'span',
          { className: 'name' },
          this.props.data.name
        ),
        React.createElement(
          'div',
          { className: 'tools' },
          React.createElement(
            'button',
            { onClick: this.toggleLinkAnnotationAdder },
            this.state.addingLinkAnnotation ? "-URL" : "+URL"
          ),
          React.createElement(
            'button',
            { onClick: this.toggleTextAnnotationAdder },
            this.state.addingTextAnnotation ? "-Text" : "+Text"
          ),
          React.createElement(
            'button',
            { onClick: this.delete },
            'X'
          )
        )
      ),
      React.createElement(
        'div',
        { className: 'body' },
        React.createElement(
          'div',
          { className: 'description' },
          this.props.data.description
        ),
        linkNodes,
        streetEasyNodes,
        textNodes,
        addLinkNodes,
        addTextNodes
      )
    );
  }
});

var AddItemWidget = React.createClass({
  displayName: 'AddItemWidget',

  getInitialState: function () {
    return { name: '', description: '' };
  },
  handleNameChange: function (e) {
    this.setState({ name: e.target.value });
  },
  handleDescriptionChange: function (e) {
    this.setState({ description: e.target.value });
  },
  handleSubmit: function (e) {
    e.preventDefault();
    var item = {
      name: this.state.name,
      description: this.state.description
    };
    if (!item.name || !item.description) {
      return;
    }

    $.ajax({
      url: `/lists/${ this.props.userId }/list/${ this.props.listId }/items`,
      dataType: 'json',
      type: 'POST',
      data: JSON.stringify(item),
      success: function (data) {
        console.log("posted new item. got respnse: " + JSON.stringify(data));
        this.props.itemAddedFn(data);
      }.bind(this),
      error: function (xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });

    this.replaceState(this.getInitialState(), function () {
      this.forceUpdate();
    }.bind(this));
  },
  render: function () {
    return React.createElement(
      'div',
      null,
      'Add Item:',
      React.createElement(
        'form',
        { onSubmit: this.handleSubmit },
        React.createElement('input', { name: 'name', placeholder: 'Name', type: 'text', value: this.state.name, onChange: this.handleNameChange }),
        React.createElement('br', null),
        React.createElement('textarea', { name: 'description', placeholder: 'Description', value: this.state.description, onChange: this.handleDescriptionChange }),
        React.createElement('br', null),
        React.createElement('input', { type: 'submit' })
      )
    );
  }
});

var List = React.createClass({
  displayName: 'List',

  getInitialState: function () {
    return { name: "", items: [] };
  },
  itemAdded: function (item) {
    console.log("List::itemAdded: " + JSON.stringify(item));
    this.setState({ items: this.state.items.concat([item]) });
  },
  deleteItem: function (id) {
    $.ajax({
      url: `/lists/${ this.props.params.userId }/list/${ this.props.params.listId }/items/${ id }`,
      type: 'DELETE',
      dataType: 'json',
      cache: false,
      success: function (data) {
        this.itemDeleted(id);
      }.bind(this),
      error: function (xhr, status, err) {
        console.error("url", status, err.toString());
      }.bind(this)
    });
  },
  itemDeleted: function (id) {
    console.log("Removing item with id: " + id);
    this.setState({ items: this.state.items.filter(function (item) {
        return item.id != id;
      }) });
  },
  itemUpdateReceived: function (e) {

    if (typeof e.data === "string") {
      var dataStr = e.data;
      this.handleItemUpdate(JSON.parse(dataStr));
      console.log("Got " + dataStr + " from WS server");
    } else {
      console.log("Unexpected non-string response!");
    }
  },
  handleItemUpdate: function (json_data) {
    var new_item = json_data;
    var new_items = this.state.items.map(function (old_item) {
      console.log("COMPARIING: " + JSON.stringify(old_item) + " vs. " + JSON.stringify(new_item));
      if (old_item.id == new_item.id) {
        console.log("new");
        return new_item;
      } else {
        console.log("old");
        return old_item;
      }
    });

    console.log("new items: " + JSON.stringify(new_items));
    this.setState({ items: new_items }, function () {
      console.log("Mutation applied");
      console.log(JSON.stringify(this.state));
    });
  },
  componentDidMount: function () {
    $.ajax({
      url: `/lists/${ this.props.params.userId }/list/${ this.props.params.listId }`,
      dataType: 'json',
      cache: false,
      success: function (data) {
        this.setState({ name: data.name, items: data.items });

        // TODO(mrjones): Negotiate the host / port?
        var endpoint = "ws://" + window.location.hostname + ":2347";
        var update_conn = new WebSocket(endpoint);
        update_conn.onopen = function () {
          var request = new sockets_api.Request();
          request.setWatchListId(this.props.params.listId);
          //          var request = new sockets_api.Request();
          //          request.setWatchListRequest(watchListRequest);
          console.log("Serialized: " + request.serializeBinary());
          update_conn.send(request.serializeBinary());
          //          update_conn.send("watch:" + this.props.params.listId);
        }.bind(this);
        update_conn.onmessage = this.itemUpdateReceived;
      }.bind(this),
      error: function (xhr, status, err) {
        console.error("url", status, err.toString());
      }.bind(this)
    });
  },
  render: function () {
    var itemNodes = this.state.items.map(function (item) {
      return React.createElement(ListItem, { data: item, key: item.id, deleteFn: this.deleteItem, userId: this.props.params.userId, listId: this.props.params.listId, itemUpdatedFn: this.handleItemUpdate });
    }.bind(this));
    return React.createElement(
      'div',
      { className: 'list' },
      React.createElement(
        'div',
        { className: 'listName' },
        this.state.name
      ),
      React.createElement(
        'div',
        null,
        React.createElement(
          'ul',
          { className: 'listItems' },
          itemNodes
        )
      ),
      React.createElement(AddItemWidget, { userId: this.props.params.userId, listId: this.props.params.listId, itemAddedFn: this.itemAdded }),
      React.createElement(SharingWidget, { myUserId: this.props.params.userId, listId: this.props.params.listId })
    );
  }
});

var NewListWidget = React.createClass({
  displayName: 'NewListWidget',

  getInitialState: function () {
    return { listName: "" };
  },
  handleSubmit: function (e) {
    e.preventDefault();
    var url = `/lists/${ this.props.userId }/list`;
    var list = { name: this.state.listName };
    $.ajax({
      url: url,
      dataType: 'json',
      type: 'POST',
      data: JSON.stringify(list),
      success: function (data) {
        this.props.listAddedFn(data);
      }.bind(this),
      error: function (xhr, status, err) {
        console.error(url, status, err.toString());
      }.bind(this)
    });
  },
  handleListNameChange(e) {
    this.setState({ listName: e.target.value });
  },
  render: function () {
    return React.createElement(
      'form',
      { onSubmit: this.handleSubmit },
      React.createElement('input', { name: 'name', type: 'text', placeholder: 'New list name', value: this.state.listName, onChange: this.handleListNameChange }),
      React.createElement('input', { type: 'submit', value: '+' })
    );
  }
});

var ListPicker = React.createClass({
  displayName: 'ListPicker',

  getInitialState: function () {
    return { lists: [] };
  },
  componentDidMount: function () {
    $.ajax({
      url: `/lists/${ this.props.userId }`,
      dataType: 'json',
      cache: false,
      success: function (data) {
        console.log(data);
        this.setState({ lists: data });
      }.bind(this),
      error: function (xhr, status, err) {
        console.error("/lists", status, err.toString());
      }.bind(this)
    });
  },
  removeList: function (e) {
    var list_id = e.target.value;
    var url = `/lists/${ this.props.userId }/list/${ list_id }`;
    console.log("Deleting " + list_id);
    $.ajax({
      url: url,
      type: 'DELETE',
      dataType: 'json',
      cache: false,
      success: function (data) {
        this.listRemoved(list_id);
      }.bind(this),
      error: function (xhr, status, err) {
        console.error(url, status, err.toString());
      }.bind(this)
    });
  },
  listRemoved: function (list_id) {
    this.setState({ lists: this.state.lists.filter(function (list) {
        return list.id != list_id;
      }) });
  },
  listAdded: function (list) {
    this.setState({ lists: this.state.lists.concat([list]) });
  },
  render: function () {
    var listNodes = this.state.lists.map(function (list) {
      return React.createElement(
        'li',
        { className: 'list', key: list.id },
        React.createElement(
          ReactRouter.Link,
          { to: `/lists/${ this.props.userId }/list/${ list.id }` },
          list.name
        ),
        '\xA0',
        React.createElement(
          'button',
          { onClick: this.removeList, value: list.id },
          'X'
        )
      );
    }, this);
    return React.createElement(
      'div',
      null,
      React.createElement(
        'ul',
        { className: 'listPicker' },
        listNodes
      ),
      React.createElement(NewListWidget, { userId: this.props.userId, listAddedFn: this.listAdded })
    );
  }
});

var SharingWidget = React.createClass({
  displayName: 'SharingWidget',

  getInitialState: function () {
    return {
      sharedWithLoaded: false,
      allUsersLoaded: false,
      sharedWithUsers: [],
      allUsers: []
    };
  },
  byId: function (a, b) {
    return a.id - b.id;
  },
  fetchAccessors: function () {
    var url = `/lists/${ this.props.myUserId }/list/${ this.props.listId }/accessors`;
    $.ajax({
      url: url,
      dataType: 'json',
      cache: false,
      success: function (data) {
        data.sort(this.byId);
        this.setState({ sharedWithLoaded: true, sharedWithUsers: data });
      }.bind(this),
      error: function (xhr, status, err) {
        console.error(url, status, err.toString());
      }.bind(this)
    });
  },
  fetchAllUsers: function () {
    var url = `/users`;
    $.ajax({
      url: url,
      dataType: 'json',
      cache: false,
      success: function (data) {
        data.sort(this.byId);
        this.setState({ allUsersLoaded: true, allUsers: data });
      }.bind(this),
      error: function (xhr, status, err) {
        console.error(url, status, err.toString());
      }.bind(this)
    });
  },
  componentDidMount: function () {
    this.fetchAccessors();
    this.fetchAllUsers();
  },
  assertSortedById: function (a) {
    for (var i = 1; i < a.length; i++) {
      if (a[i - 1].id > a[i].id) {
        console.error("Not sorted at index " + i);
      }
    }
  },
  unsharedUsers: function () {
    this.assertSortedById(this.state.allUsers);
    this.assertSortedById(this.state.sharedWithUsers);

    var unshared = [];
    var sharedIdx = 0;
    for (var allIdx = 0; allIdx < this.state.allUsers.length; allIdx++) {
      while (sharedIdx < this.state.sharedWithUsers.length && this.state.sharedWithUsers[sharedIdx].id < this.state.allUsers[allIdx].id) {
        sharedIdx++;
      }
      if (sharedIdx == this.state.sharedWithUsers.length || this.state.sharedWithUsers[sharedIdx].id > this.state.allUsers[allIdx].id) {
        unshared.push(this.state.allUsers[allIdx]);
      }
    }

    return unshared;
  },
  addUserToList: function (userId) {
    var url = `/lists/${ this.props.myUserId }/list/${ this.props.listId }/accessors`;
    $.ajax({
      url: url,
      dataType: 'json',
      type: 'POST',
      data: JSON.stringify({ id: userId }),
      cache: false,
      success: function (data) {
        this.setState({ sharedWithUsers: data });
      }.bind(this),
      error: function (xhr, status, err) {
        console.error(url, status, err.toString());
      }.bind(this)
    });
  },
  removeUserFromList: function (userId) {
    var url = `/lists/${ this.props.myUserId }/list/${ this.props.listId }/accessors`;
    $.ajax({
      url: url,
      dataType: 'json',
      type: 'DELETE',
      data: JSON.stringify({ id: userId }),
      cache: false,
      success: function (data) {
        this.setState({ sharedWithUsers: data });
      }.bind(this),
      error: function (xhr, status, err) {
        console.error(url, status, err.toString());
      }.bind(this)
    });
  },
  render: function () {
    if (!this.state.sharedWithLoaded || !this.state.allUsersLoaded) {
      return React.createElement(
        'div',
        null,
        'Loading...'
      );
    }

    var allUserNodes = this.state.sharedWithUsers.map(function (user) {
      var deleteButton;
      if (this.props.myUserId != user.id) {
        deleteButton = React.createElement(
          'button',
          { onClick: this.removeUserFromList.bind(this, user.id) },
          'X'
        );
      }
      return React.createElement(
        'li',
        { key: user.id },
        user.name,
        deleteButton
      );
    }.bind(this));

    var unsharedUserNodes = this.unsharedUsers().map(function (user) {
      return React.createElement(
        'li',
        { key: user.id },
        user.name,
        React.createElement(
          'button',
          { onClick: this.addUserToList.bind(this, user.id) },
          '+'
        )
      );
    }.bind(this));

    return React.createElement(
      'div',
      null,
      'Shared with:',
      React.createElement(
        'ul',
        null,
        allUserNodes
      ),
      'Not Shared with:',
      React.createElement(
        'ul',
        null,
        unsharedUserNodes
      )
    );
  }
});

// ReactDOM.render(
//  <Widget />,
//  document.getElementById('content')
// );

// https://www.kirupa.com/react/creating_single_page_app_react_using_react_router.htm
ReactDOM.render(React.createElement(
  ReactRouter.Router,
  { history: ReactRouter.hashHistory },
  React.createElement(ReactRouter.Route, { path: '/', component: UserPicker }),
  React.createElement(
    ReactRouter.Route,
    { path: '/lists/:userId', component: App },
    React.createElement(ReactRouter.IndexRoute, { component: ListPicker }),
    React.createElement(ReactRouter.Route, { path: 'list/:listId', component: List })
  )
), document.getElementById('content'));

},{"./api_pb.js":1,"./model.js":3,"./sockets_api_pb.js":4,"jquery":"jquery","react":"react","react-dom":"react-dom","react-router":"react-router"}],3:[function(require,module,exports){
var api = require('./api_pb.js');

function user_from_json(json) {
  var user = new api.User();
  user.setName(json.name);
  user.setId(json.id);
  return user;
}

class StreetEasyAnnotation {

  static from_json(json) {
    var annotation = new StreetEasyAnnotation();
    annotation.hash = json.hash;
    annotation.name = "flow:" + json.name;
    annotation.price_usd = json.price_usd;
    annotation.open_houses = json.open_houses;
    return annotation;
  }
}

class ListItem {

  static from_json(json_item) {
    var item = new ListItem();
    item.name = json_item.name;
    item.description = json_item.description;
    item.text_annotations = json_item.text_annotations;
    item.link_annotations = json_item.link_annotations;
    item.streeteasy_annotations = json_item.streeteasy_annotations.map(StreetEasyAnnotation.from_json);
    return item;
  }
}

class List {

  static from_json(json) {
    var list = new List();
    list.name = json.name;
    list.items = json.items.map(ListItem.from_json);
    return list;
  }
}

module.exports = {
  user_from_json,

  List,
  ListItem,
  StreetEasyAnnotation
};

},{"./api_pb.js":1}],4:[function(require,module,exports){
/**
 * @fileoverview
 * @enhanceable
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

goog.exportSymbol('proto.Request', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.Request = function (opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.Request, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.Request.displayName = 'proto.Request';
}

if (jspb.Message.GENERATE_TO_OBJECT) {
  /**
   * Creates an object representation of this proto suitable for use in Soy templates.
   * Field names that are reserved in JavaScript and will be renamed to pb_name.
   * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
   * For the list of reserved names please see:
   *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
   * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
   *     for transitional soy proto support: http://goto/soy-param-migration
   * @return {!Object}
   */
  proto.Request.prototype.toObject = function (opt_includeInstance) {
    return proto.Request.toObject(opt_includeInstance, this);
  };

  /**
   * Static version of the {@see toObject} method.
   * @param {boolean|undefined} includeInstance Whether to include the JSPB
   *     instance for transitional soy proto support:
   *     http://goto/soy-param-migration
   * @param {!proto.Request} msg The msg instance to transform.
   * @return {!Object}
   */
  proto.Request.toObject = function (includeInstance, msg) {
    var f,
        obj = {
      watchListId: jspb.Message.getFieldWithDefault(msg, 1, 0)
    };

    if (includeInstance) {
      obj.$jspbMessageInstance = msg;
    }
    return obj;
  };
}

/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.Request}
 */
proto.Request.deserializeBinary = function (bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.Request();
  return proto.Request.deserializeBinaryFromReader(msg, reader);
};

/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.Request} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.Request}
 */
proto.Request.deserializeBinaryFromReader = function (msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
      case 1:
        var value = /** @type {number} */reader.readInt64();
        msg.setWatchListId(value);
        break;
      default:
        reader.skipField();
        break;
    }
  }
  return msg;
};

/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.Request} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.Request.serializeBinaryToWriter = function (message, writer) {
  message.serializeBinaryToWriter(writer);
};

/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.Request.prototype.serializeBinary = function () {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};

/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.Request.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getWatchListId();
  if (f !== 0) {
    writer.writeInt64(1, f);
  }
};

/**
 * optional int64 watch_list_id = 1;
 * @return {number}
 */
proto.Request.prototype.getWatchListId = function () {
  return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
  );
};

/** @param {number} value */
proto.Request.prototype.setWatchListId = function (value) {
  jspb.Message.setField(this, 1, value);
};

goog.object.extend(exports, proto);

},{"google-protobuf":"google-protobuf"}]},{},[2,4]);
